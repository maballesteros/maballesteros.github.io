---
title: Mobile Agents on the Internet – Aglets SDK (III)
excerpt: "Final article in the 1999 series, now in English, walking through the Aglet class API, proxies, messaging, and sample agents."
tags: [rpp, agents, java]
lang: en
ref: aglets-3
modified: 2025-10-19
comments: true
permalink: /en/blog/aglets-3/
---

The last chapter of my original RPP trilogy focused on writing actual code with the Aglets SDK. This translation keeps the spirit of that tutorial: show the essential APIs, explain the lifecycle hooks, and demonstrate how little code you need to produce seemingly complex behaviours.

---

## Anatomy of an Aglet

An aglet is a Java object that extends `com.ibm.aglet.Aglet`. The base class groups its methods into five broad categories:

1. **Lifecycle operations** – `dispatch(URL)`, `clone()`, `dispose()`, … (final methods you *call*).
2. **Lifecycle callbacks** – `onCreation()`, `onDispatching()`, `onArrival()`, `onReverting()`, `onDisposing()`, … (methods you override to react to events).
3. **Messaging** – `handleMessage(Message)`, `sendMessage()`, `sendAsyncMessage()`.
4. **Introspection** – `getAgletID()`, `getAgletInfo()`, custom attributes.
5. **Context interaction** – `getAgletContext()`, registering listeners, subscribing to context events.

The sequencing looks like this:

```text
create() → onCreation() → [dispatch()] → onDispatching() → travel → onArrival()
```

At any point agents can receive custom messages, which arrive through `handleMessage`. Return `true` when you consume a message; return `false` to let the runtime try default handlers.

## Proxies and security

When an agent wants to talk to another agent it never gets the raw object reference. Instead it asks the context for an `AgletProxy`, which:

- Mediates all method calls to enforce security policies.
- Exposes communication primitives (sync/async messaging, future replies).
- Provides metadata such as the target agent’s identifier.

Example:

```java
AgletProxy proxy = getAgletContext().getAgletProxies().nextElement();

Message msg = new Message("Hello");
FutureReply reply = proxy.sendAsyncMessage(msg);

// Do other work...
Object result = reply.getReply(); // blocks until the agent responds
```

## Sample agents

The magazine article presented two tiny but illustrative examples:

1. **Explorer** – cycles through a list of remote hosts, inspecting which agents live there, logging findings back home.
2. **Market agent** – migrates to multiple information kiosks, negotiates prices via asynchronous messages, and returns with the best offer.

Each agent fits in a couple dozen lines of Java thanks to the lifecycle hooks and the messaging API.

## Beyond the tutorial

We closed the series by speculating about e-commerce scenarios where fleets of mobile agents would compare prices, monitor inventory, or personalise services close to where the data lives. While the Web took a different direction (microservices and serverless rather than roaming bytecode), the architectural ideas reappear today in edge computing, WASM workers, and federated AI training.

If you’d like the full nostalgic experience, grab the original Spanish scans at `/images/1999-aglets/imagen-3c.jpg`. And if you missed the earlier parts, start with [Part I](/en/blog/aglets-1/) for the conceptual groundwork and [Part II](/en/blog/aglets-2/) for the SDK tour.
