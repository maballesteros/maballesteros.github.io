---
title: Mobile Agents on the Internet – Aglets SDK (II)
excerpt: "Second article in the 1999 series, translated to English, covering IBM’s Aglets platform, its architecture, and the developer tooling that shipped with Tahiti."
tags: [rpp, agents, java]
lang: en
ref: aglets-2
modified: 2025-10-19
comments: true
permalink: /en/blog/aglets-2/
---

Picking up where Part I left off, this translated article introduces the **Aglets SDK**, IBM Tokyo Lab’s implementation of autonomous mobile agents for Java. In 1999 it was one of several competing platforms (Concordia, Odyssey, Voyager…), but Aglets stood out for its clean API and the ease with which you could experiment.

---

## The Aglets SDK at a glance

- **Origin:** IBM Tokyo Research Laboratory.  
- **Goal:** Provide a complete development and runtime environment for mobile agents (“aglets”) built on Java.  
- **Distribution:** Free download including APIs, compiler support, examples, and a graphical host called **Tahiti**.

Danny Lange, the original mind behind aglets, described them as “the next abstraction level after object-oriented programming.” Java’s portable bytecode and security model made it feasible to run self-moving agents across heterogeneous networks.

Tahiti, the bundled host application, lets you spawn, inspect, pause, and migrate agents interactively—a perfect playground to internalise the concepts.

## Getting started: the HelloAglet example

The magazine article walked readers through compiling and launching the canonical sample:

1. Start **Tahiti** (the agent host).  
2. Launch the `HelloAglet` agent; the runtime invokes its `onCreation()` method.  
3. The agent displays a dialog asking for a destination host and greeting message.  
4. When you press **GO!**, the UI sends a `startTrip` message to the agent.
5. `HelloAglet` uses a `SimpleItinerary` helper to travel to the remote host, where it receives `sayHello` and displays the greeting.
6. After a few seconds it returns to the origin, receives `atHome`, shows a goodbye message, and destroys itself.

The exercise demonstrated how natural the programming model feels: agents react to lifecycle events (`onCreation`, `onDispatch`, `onArrival`, `onDisposing`) and to application-defined messages.

## Architecture highlights

The API is organised around three main abstractions:

- **`AgletContext`** – the host environment (e.g., Tahiti). It manages agent lifecycles, persistence, and discovery.
- **`Aglet`** – the base class for your mobile agents. You subclass it and override callbacks to define behaviour.
- **`AgletProxy`** – a protective wrapper that other agents use to communicate without touching the real object directly.

Why proxies? Security. If one agent could grab a raw reference to another agent, it could use reflection to bypass the public API. Instead, the context only hands out `AgletProxy` instances that mediate calls and enforce policies.

Communication happens via asynchronous messages. Agents send `Message` objects through proxies, and the recipient’s `handleMessage` method decides how to react.

## What’s next

By the end of Part II readers had a working mental model of the Aglets runtime plus hands-on experience with the sample agent. The final chapter of the series (translated [here](/en/blog/aglets-3/)) dives deeper into programming patterns, mobility primitives, and security concerns so you can craft your own distributed applications.
